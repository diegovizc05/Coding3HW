package Driver;
import java.util.*;

public class HashTable {
    public static void main(String[] args) {

        HashTableOpenAddressing<Integer, String> ht = new HashTableOpenAddressing<>(5);

        System.out.println("=== Adding Elements ===");
        ht.add(1, "Apple");
        ht.add(2, "Banana");
        ht.add(3, "Cherry");
        ht.add(8, "Dragonfruit");   // Collision with 3

        ht.printTable();

        System.out.println("\n=== Searching ===");
        System.out.println("Key 2 -> " + ht.get(2));
        System.out.println("Key 8 -> " + ht.get(8));

        System.out.println("\n=== Removing Key 3 ===");
        ht.remove(3);

        ht.printTable();

        System.out.println("\n=== Adding More (Trigger Resize) ===");
        ht.add(4, "Grape");
        ht.add(5, "Mango");
        ht.add(6, "Watermelon");

        ht.printTable();
    }
}

class HashTableOpenAddressing<K, V> {

    private static class Entry<K, V> {
        K key;
        V value;
        boolean isDeleted;

        Entry(K key, V value) {
            this.key = key;
            this.value = value;
            this.isDeleted = false;
        }
    }

    private Entry<K, V>[] table;
    private int size;
    private int capacity;
    private final double loadFactor = 0.75;

    @SuppressWarnings("unchecked")
    public HashTableOpenAddressing(int capacity) {
        this.capacity = capacity;
        this.table = new Entry[capacity]; // empty-since-start
        this.size = 0;
    }

    // Hash function using modulo
    private int getHashing(K key) {
        return Math.abs(key.hashCode()) % capacity;
    }

    // Linear probing
    private int probing(int index) {
        return (index + 1) % capacity;
    }

    // Resize when load factor exceeded
    private void resize() {
        System.out.println("\n[Table resizing... new capacity = " + (capacity * 2) + "]");

        int oldCapacity = capacity;
        capacity *= 2;

        Entry<K, V>[] oldTable = table;

        table = new Entry[capacity];
        size = 0;

        for (int i = 0; i < oldCapacity; i++) {
            if (oldTable[i] != null && !oldTable[i].isDeleted) {
                add(oldTable[i].key, oldTable[i].value);
            }
        }
    }

    // Insert key-value pair
    public void add(K key, V value) {
        if ((double) size / capacity >= loadFactor) {
            resize();
        }

        int index = getHashing(key);

        while (table[index] != null && !table[index].isDeleted && !table[index].key.equals(key)) {
            index = probing(index);
        }

        if (table[index] == null || table[index].isDeleted) {
            size++;
        }

        table[index] = new Entry<>(key, value);
    }

    // Search
    public V get(K key) {
        int index = getHashing(key);

        while (table[index] != null) {
            if (!table[index].isDeleted && table[index].key.equals(key)) {
                return table[index].value;
            }
            index = probing(index);
        }

        return null;
    }

    // Remove key
    public void remove(K key) {
        int index = getHashing(key);

        while (table[index] != null) {
            if (!table[index].isDeleted && table[index].key.equals(key)) {
                table[index].isDeleted = true;
                size--;
                return;
            }
            index = probing(index);
        }
    }

    // Display table
    public void printTable() {
        System.out.println("\n=== Hash Table State ===");
        for (int i = 0; i < capacity; i++) {
            if (table[i] == null) {
                System.out.println(i + ": [Empty]");
            } else if (table[i].isDeleted) {
                System.out.println(i + ": [Deleted]");
            } else {
                System.out.println(i + ": " + table[i].key + " â†’ " + table[i].value);
            }
        }
    }
}



